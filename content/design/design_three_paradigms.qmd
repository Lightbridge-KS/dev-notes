# Three Programming Paradigms 

![Programming Types Example](../../img/design/programming-types.png){#fig-programming-types width="100%"}

---

## 1Â â€“Â Programming to an *implementation*

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          (no abstraction layer)
â”‚   Client     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚   â€œknows concrete Dogâ€
                              â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   Dog    â”‚
                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                        â”‚ +bark()  â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# --- rigid, concrete design ---------------------------------
class Dog:
    def bark(self) -> None:
        print("Woof!")

# Client
d = Dog()       # must be a Dog here
d.bark()
```

---

## 2Â â€“Â Programming to an *interface / super-type*

```
                    Â«interfaceÂ»
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚   Animal     â”‚
                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                 â”‚ +makeSound() â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â–²       â–²
                     â”‚       â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Dog    â”‚             â”‚   Cat    â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚+makeSoundâ”‚             â”‚+makeSoundâ”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â–²
                 â”‚  (depends on interface only)
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚    Client    â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def make_sound(self) -> None: ...

class Dog(Animal):
    def make_sound(self) -> None:
        print("Woof!")

class Cat(Animal):
    def make_sound(self) -> None:
        print("Meow!")

# Client sees only the Animal API
animal: Animal = Dog()
animal.make_sound()
```

---

## 3Â â€“Â Binding the concrete type *at runtime* (Factory / DI)

```
                    Â«interfaceÂ»
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚   Animal     â”‚
                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                 â”‚ +makeSound() â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â–²       â–²
                     â”‚       â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Dog    â”‚             â”‚   Cat    â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚+makeSoundâ”‚             â”‚+makeSoundâ”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        (creates & returns Animal)
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    AnimalFactory        â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ +create() : Animal      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚    Client    â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
import random
from abc import ABC, abstractmethod
from typing import List

# interface
class Animal(ABC):
    @abstractmethod
    def make_sound(self) -> None: ...

# concrete types
class Dog(Animal):
    def make_sound(self) -> None:
        print("Woof!")

class Cat(Animal):
    def make_sound(self) -> None:
        print("Meow!")

# factory (could also be config, DI container, etc.)
def animal_factory() -> Animal:
    return random.choice([Dog(), Cat()])

# Client codeâ€”zero knowledge of concrete classes
pet = animal_factory()
pet.make_sound()
```

---

### At a glance

| Style                  | Client depends on | Who decides the concrete class?              | Flexibility         |
| ---------------------- | ----------------- | -------------------------------------------- | ------------------- |
| Implementation         | `Dog` directly    | The client *in source code*                  | Rigid               |
| Interface / super-type | `Animal`          | The client, but can swap per call-site       | Moderately flexible |
| Runtime binding        | `Animal`          | A factory / DI / config *outside* the client | Highly flexible     |

Choose the lightest approach that meets your projectâ€™s change-tolerance needs.


## Factory vs DI vs Config

Below is a quick orientation first, then deeper dives with **side-by-side code** for three common ways to decouple *creation* from *use* of an object when you â€œbind the concrete type at runtime.â€

| Aspect                              | **Factory**                                           | **Dependency Injection (DI)**                                                                            | **Config-driven**                                                                              |
| ----------------------------------- | ----------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| Where does the creation logic live? | In a *factory function/class* that returns the object | In the *composition root* (or a DI container) that **builds** the object and **injects** it into clients | Outside the codebaseâ€” a file/env/CLI flag decides *what* to build; code interprets that config |
| What does the client know?          | Only the factoryâ€™s API                                | Only the **interface** (`Animal`)                                                                        | Only the interface and a *config accessor*                                                     |
| How do you swap implementations?    | Change the factoryâ€™s internals                        | Wire a different object when composing or configure the container                                        | Edit the config file / env var (no code change)                                                |
| Typical patterns/frameworks         | *Factory Method*, *Abstract Factory*                  | Manual DI, `dependency_injector`, `injector`, FastAPI/Flask providers                                    | `.ini`, `.yaml`, `.toml`, environment variables, feature-flags                                 |

---

### Shared setup: the interface and two concrete classes

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def make_sound(self) -> None: ...

class Dog(Animal):
    def make_sound(self) -> None:
        print("Woof!")

class Cat(Animal):
    def make_sound(self) -> None:
        print("Meow!")
```

---

### 1  Factory pattern

A **factory** owns the *decision* and the *construction*.

```python
import random

def animal_factory(kind: str | None = None) -> Animal:
    """Return an Animal, choice decided here."""
    if kind == "dog":
        return Dog()
    if kind == "cat":
        return Cat()
    # default = random
    return random.choice([Dog(), Cat()])

# â”€â”€â”€ client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pet = animal_factory("dog")      # caller just says â€œgive me a dogâ€
pet.make_sound()
```

*Change point*: only the `animal_factory` body.

---

### 2  Dependency-Injection (manual or with a container)

Creation happens **outside** the part of the code that *uses* the object.
The *client* receives an `Animal` via parameter or constructor.

```python
# business logic â€” agnostic of concrete type
def play_with_pet(pet: Animal) -> None:
    pet.make_sound()
    # â€¦more work with petâ€¦

# â”€â”€â”€ composition root (main.py, framework bootstrap, etc.) â”€
def main() -> None:
    # choose concrete class *here*
    my_pet: Animal = Dog()              # or Cat(), or TestDummyAnimal()
    play_with_pet(my_pet)               # injected dependency

if __name__ == "__main__":
    main()
```

#### Using a tiny DI container (*optional*)

```python
from dependency_injector import containers, providers  # pip install dependency-injector

class Container(containers.DeclarativeContainer):
    animal = providers.Factory(Dog)   # switch to Cat by editing one line

container = Container()
play_with_pet(container.animal())
```

*Change point*: a single provider registration lineâ€”tests can override it.

---

### 3  Config-driven instantiation

The choice is moved to **data**. Code merely *reads* the config and instantiates accordingly (often using a factory under the hood).

```python
import json
from pathlib import Path

# config.json  â†’  {"animal": "cat"}
config = json.loads(Path("config.json").read_text())
kind = config.get("animal", "dog")     # default if key missing

# Usually you still reuse a factory or a mapping:
ANIMAL_MAP: dict[str, type[Animal]] = {"dog": Dog, "cat": Cat}

pet_class = ANIMAL_MAP[kind]
pet = pet_class()          # build the concrete object dictated by config

play_with_pet(pet)
```

Now *non-developers* (DevOps, operators, even a feature-flag service) can switch the implementation without touching code or redeploying.

---

### Putting it all together

* **Factory** centralises construction logicâ€”good when you *own* the factory and callers shouldnâ€™t care about the creation details.
* **Dependency Injection** pushes creation entirely outside the consumer; the object arrives â€œpre-built.â€ Ideal for testability and pluggable architecturesâ€”frameworks often supply DI containers to automate the wiring.
* **Config-driven** externalises the *decision* to data; your code becomes generic, and runtime behaviour changes by editing config, environment variables, or a feature-flag service. Often, a DI container or factory uses that config under the hood.

Use whichever mechanism minimises coupling **and** fits the complexity budget of your project.

## DI container

### What exactly *is* a â€œDI containerâ€?

> **Dependency-Injection (DI) container**
> A software component (library or framework) that *automates* the two jobs at the heart of dependency injection:
>
> 1. **Construction** â€“ It creates all the concrete objects your application needs.
> 2. **Wiring** â€“ It resolves every objectâ€™s dependencies and supplies them at the right place (constructor, method, attribute, etc.).

Because the container, not your business code, â€œownsâ€ object creation and composition, we say it inverts control of that concernâ€”hence the alternative name **IoC container** (Inversion-of-Control container).

---

### Core responsibilities

| Responsibility                                                           | What it does                                                                                                 | Why it helps                                                                     |
| ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------- |
| **Registration**                                                         | You *register* mappings: â€œWhen someone asks for `Animal`, build a `Dog` (or whatever).â€                      | Centralises knowledge of concrete classesâ€”no scattering `Dog()` calls.           |
| **Resolution / Object-graph building**                                   | When code needs an `Animal`, the container recursively instantiates `Animal` *and everything it depends on*. | You write plain constructors; the container builds the full graph.               |
| **Lifetime / scope management**                                          | Decides whether each object is `Singleton`, `Transient`, `Request-scoped`, etc.                              | Prevents global singletons and accidental resource leaks.                        |
| **Optionally: interception, configuration, auto-wiring, health checksâ€¦** | Advanced containers add AOP-style interceptors, config binding, reflection-based auto-wiring, etc.           | Cuts boilerplate and enables cross-cutting concerns (logging, metrics, caching). |

---

### Mini Python example with `dependency-injector`

```python
# pip install dependency-injector
from dependency_injector import containers, providers
from abc import ABC, abstractmethod


# â”€â”€ Interfaces & implementations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Animal(ABC):
    @abstractmethod
    def make_sound(self) -> None: ...


class Dog(Animal):
    def __init__(self, name: str) -> None:
        self.name = name

    def make_sound(self) -> None:
        print(f"{self.name}: Woof!")


# â”€â”€ Business logic (no knowledge of concrete classes) â”€â”€â”€â”€â”€â”€â”€
def play_with_pet(pet: Animal) -> None:
    pet.make_sound()


# â”€â”€ DI container (composition root) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Container(containers.DeclarativeContainer):
    config = providers.Configuration()          # binds env / YAML / etc.
    animal = providers.Factory(                 # every call returns *new* Dog
        Dog,
        name=config.pet_name.from_value("Buddy")
    )


# â”€â”€ Application bootstrap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    container = Container()
    # could load YAML or env vars here â†’ container.config.from_yaml("cfg.yml")

    pet = container.animal()       # container resolves & builds Dog("Buddy")
    play_with_pet(pet)
```

**What happened?**

1. **Registration** â€“ `animal = providers.Factory(Dog, â€¦)` tells the container *how* to make an `Animal`.
2. **Resolution** â€“ `container.animal()` asks the container for an `Animal`; it constructs a `Dog`, providing the `name` parameter from config.
3. **Injection** â€“ `play_with_pet` receives the ready-to-use `Dog` without importing or instantiating it.

Swap `Dog` for `Cat`, change lifetimes, or override providers in tests **without touching** `play_with_pet`.

---

### Benefits & trade-offs at a glance

| ğŸ‘ Pros                                                         | ğŸ‘ Cons                                                    |
| --------------------------------------------------------------- | ---------------------------------------------------------- |
| **Loosened coupling:** business code depends only on interfaces | Extra abstractionâ€”may feel heavy for small scripts         |
| **Centralised wiring:** one place to see/alter composition      | Reflection-based auto-wiring can hide dependencies (magic) |
| **Testability:** easily inject mocks/stubs/fakes                | Learning curve; container misuse can hurt performance      |
| **Lifecycle control:** singleton vs per-request vs transient    | Another runtime dependency to manage                       |

In short, a DI container packages the â€œwho builds what, and whenâ€ logic into a reusable, configurable serviceâ€”letting your domain code focus purely on *what* it needs to do.
